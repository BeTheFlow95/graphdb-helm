NAME: graphdb-ee
LAST DEPLOYED: Sun Feb 21 15:59:08 2021
NAMESPACE: default
STATUS: pending-install
REVISION: 1
TEST SUITE: None
HOOKS:
MANIFEST:
---
# Source: gdb-ee/templates/configuration/graphdb-master-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: graphdb-configmap
  labels:
    name: graphdb-configmap
data:
  # >- means replace new line with space and no new lines at the end
  GDB_JAVA_OPTS: >-
    -Denable-context-index=true
    -Dentity-pool-implementation=transactional
    -Dhealth.max.query.time.seconds=60
    -Dgraphdb.workbench.external-url=graphdb.local/graphdb
    -Dgraphdb.append.request.id.headers=true
    -Dgraphdb.workbench.importDirectory=/opt/graphdb/home/graphdb-import
    -Dgraphdb.auth.token.secret="s3cr37"
     -Xmx4G -XX:MaxRAMPercentage=70 -XX:+UseContainerSupport
---
# Source: gdb-ee/templates/configuration/graphdb-master-repo-default-configmap.yaml
# Default configuration map for provisioning GraphDB repository.
# To change it, prepare another configuration map and update "graphdb.repositoryConfigmap"
apiVersion: v1
kind: ConfigMap
metadata:
  name: graphdb-repo-default-configmap
  labels:
    name: graphdb-repo-default-configmap
data:
  config.ttl: |-

    #
    # RDF4J configuration template for a GraphDB EE worker repository
    #
    @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
    @prefix rep: <http://www.openrdf.org/config/repository#>.
    @prefix sr: <http://www.openrdf.org/config/repository/sail#>.
    @prefix sail: <http://www.openrdf.org/config/sail#>.
    @prefix owlim: <http://www.ontotext.com/trree/owlim#>.
    
    [] a rep:Repository ;
        rep:repositoryID "soaas" ;
        rdfs:label "GraphDB master for soaas" ;
        rep:repositoryImpl [
            rep:repositoryType "owlim:ReplicationCluster" ;
        ].
---
# Source: gdb-ee/templates/configuration/graphdb-worker-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: graphdb-worker-1-configmap
  labels:
    name: graphdb-worker-1-configmap
data:
  # >- means replace new line with space and no new lines at the end
  GDB_JAVA_OPTS: >-
    -Denable-context-index=true
    -Dentity-pool-implementation=transactional
    -Dhealth.max.query.time.seconds=60
    -Dgraphdb.workbench.external-url=graphdb.local/graphdb-worker-1
    -Dgraphdb.append.request.id.headers=true
    -Dgraphdb.auth.token.secret="s3cr37"
     -Xmx2G -XX:MaxRAMPercentage=70 -XX:+UseContainerSupport
---
# Source: gdb-ee/templates/configuration/graphdb-worker-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: graphdb-worker-2-configmap
  labels:
    name: graphdb-worker-2-configmap
data:
  # >- means replace new line with space and no new lines at the end
  GDB_JAVA_OPTS: >-
    -Denable-context-index=true
    -Dentity-pool-implementation=transactional
    -Dhealth.max.query.time.seconds=60
    -Dgraphdb.workbench.external-url=graphdb.local/graphdb-worker-2
    -Dgraphdb.append.request.id.headers=true
    -Dgraphdb.auth.token.secret="s3cr37"
     -Xmx1G -XX:MaxRAMPercentage=70 -XX:+UseContainerSupport
---
# Source: gdb-ee/templates/configuration/graphdb-worker-repo-default-configmap.yaml
# Default configuration map for provisioning GraphDB worker node repository.
# To change it, prepare another configuration map and update "graphdb.cluster.worker.repositoryConfigmap"
apiVersion: v1
kind: ConfigMap
metadata:
  name: graphdb-worker-repo-default-configmap
  labels:
    name: graphdb-worker-repo-default-configmap
data:
  config.ttl: |-
    #
    # RDF4J configuration template for a GraphDB EE worker repository
    #
    @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
    @prefix rep: <http://www.openrdf.org/config/repository#>.
    @prefix sr: <http://www.openrdf.org/config/repository/sail#>.
    @prefix sail: <http://www.openrdf.org/config/sail#>.
    @prefix owlim: <http://www.ontotext.com/trree/owlim#>.
    @prefix shacl: <http://rdf4j.org/config/sail/shacl#>.
    
    [] a rep:Repository ;
        rep:repositoryID "soaas" ;
        rdfs:label "GraphDB worker for soaas" ;
        rep:repositoryImpl [
            rep:repositoryType "owlim:ReplicationClusterWorker" ;
            rep:delegate [
                rep:repositoryType "owlim:MonitorRepository" ;
                sr:sailImpl [
                    sail:sailType "rdf4j:ShaclSail";
                    shacl:validationEnabled "true" ;
                    shacl:logValidationPlans "false" ;
                    shacl:logValidationViolations "false" ;
                    shacl:parallelValidation "true" ;
                    shacl:globalLogValidationExecution "false" ;
                    shacl:cacheSelectNodes "true" ;
                    shacl:undefinedTargetValidatesAllSubjects "false" ;
                    shacl:ignoreNoShapesLoadedException "false" ;
                    shacl:performanceLogging "false" ;
                    shacl:rdfsSubClassReasoning "true" ;
                    shacl:shaclAdvancedFeatures "true" ;
                    shacl:dashDataShapes "true" ;
                    sail:delegate [
                      sail:sailType "owlimClusterWorker:Sail";
                      owlim:owlim-license "" ;
                      owlim:base-URL "http://example.org/owlim#" ;
                      owlim:defaultNS "" ;
                      owlim:entity-index-size "10000000" ;
                      owlim:entity-id-size  "32" ;
                      owlim:imports "" ;
                      owlim:repository-type "file-repository" ;
                      owlim:ruleset "rdfsplus-optimized" ;
                      owlim:storage-folder "storage" ;
                      owlim:enable-context-index "false" ;
                      owlim:enablePredicateList "true" ;
                      owlim:in-memory-literal-properties "true" ;
                      owlim:enable-literal-index "true" ;
                      owlim:check-for-inconsistencies "false" ;
                      owlim:disable-sameAs  "true" ;
                      owlim:query-timeout  "0" ;
                      owlim:query-limit-results  "0" ;
                      owlim:throw-QueryEvaluationException-on-timeout "false" ;
                      owlim:read-only "false" ;
                      owlim:nonInterpretablePredicates "http://www.w3.org/2000/01/rdf-schema#label;http://www.w3.org/1999/02/22-rdf-syntax-ns#type;http://www.ontotext.com/owlim/ces#gazetteerConfig;http://www.ontotext.com/owlim/ces#metadataConfig" ;
                    ]
                ]
            ]
        ].
---
# Source: gdb-ee/templates/configuration/kong-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: kong-configmap
  labels:
    app: kong-configmap
data:
  KONG_DATABASE: "off"
  KONG_DECLARATIVE_CONFIG: "/etc/kong/kong.yaml"
  KONG_MEM_CACHE_SIZE: "64m"
  KONG_NGINX_WORKER_PROCESSES: "auto"
  KONG_ADMIN_LISTEN: "0.0.0.0:8001, 0.0.0.0:8444 ssl"
  KONG_PROXY_ACCESS_LOG: "/dev/stdout"
  KONG_ADMIN_ACCESS_LOG: "/dev/stdout"
  KONG_PROXY_ERROR_LOG: "/dev/stderr"
  KONG_ADMIN_ERROR_LOG: "/dev/stderr"
---
# Source: gdb-ee/templates/configuration/kong-services-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: kong-services-configmap
  labels:
    app: kong-services-configmap
data:
  kong.yaml: |-
    # Some notes before digging into this configuration
    # This is Kong's DB less configuration, i.e. this work without a database.
    # The configuration is static and Kong cannot be customized without providing a new declarative configuration.
    # See more at https://docs.konghq.com/2.0.x/db-less-and-declarative-config/
    #
    # This file is prepared for Helm chart templates.
    # See https://helm.sh/docs/chart_template_guide/control_structures/
    #
    # Note: to validate this configuration without running the chart, use
    # docker run -it --rm -v $(pwd):/tmp/files -e KONG_DATABASE=off kong:2.1-alpine kong config parse /tmp/files/kong.dbless.yaml
    
    _format_version: "1.1"
    
    plugins:
      # Refer to https://docs.konghq.com/hub/kong-inc/correlation-id/
      # This is configured to trigger for all services/routes and to return it to the client.
      - name: correlation-id
        config:
          # Match the one used by semantic objects
          header_name: X-Request-ID
          generator: uuid
          # Make Kong return the header to the clients
          echo_downstream: true
    
    services:
      - name: graphdb
        url: http://graphdb:7200
        connect_timeout: 60000
        read_timeout: 60000
        write_timeout: 60000
        routes:
          - name: graphdb
            paths: ["/graphdb"]
            methods: ["GET", "POST", "PUT", "DELETE"]
            strip_path: true
            preserve_host: false
    
      #  cluster & expose check
---
# Source: gdb-ee/templates/graphdb-utils-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: graphdb-utils-configmap
  labels:
    name: graphdb-utils-configmap
data:
  graphdb.sh: |-
    #!/usr/bin/env sh
    
    set -eu
    #TODO: Add a function which sets a master as read only
    function waitService() {
      address=$1
    
      attempt_counter=0
      max_attempts=100
    
      echo "Waiting for ${address}"
      until $(curl --output /dev/null --silent --fail ${address}); do
        if [[ ${attempt_counter} -eq ${max_attempts} ]];then
          echo "Max attempts reached"
          exit 1
        fi
    
        printf '.'
        attempt_counter=$(($attempt_counter+1))
        sleep 5
      done
    }
    
    waitMaster() {
      master_address=$1
      master_repo=$2
    
      waitService "${master_address}/rest/repositories"
      waitService "${master_address}/rest/repositories/${master_repo}/size"
      waitService "${master_address}/rest/cluster/masters/${master_repo}"
    }
    
    linkWorker() {
      master_address=$1
      worker_address=$2
      repository=$3
      master_repo=$4
    
      waitService "http://localhost:7200/repositories/${repository}/size"
    
      worker_repo_endpoint="${worker_address}/repositories/${repository}"
    
      echo "Adding worker as remote location"
    
      curl ${master_address}/rest/locations -H 'Content-Type:application/json' \
      -H 'Accept: application/json, text/plain, */*' \
      --data-raw "{\"uri\":\"${worker_address}\",\"username\":\"\", \"password\":\"\", \"active\":\"false\"}"
    
      echo "Linking worker"
      curl -o response.json -sf -X POST ${master_address}/jolokia/ \
          --header 'Content-Type: multipart/form-data' \
          --data-raw "{
            \"type\": \"exec\",
            \"mbean\": \"ReplicationCluster:name=ClusterInfo/${repository}\",
            \"operation\": \"addClusterNode\",
            \"arguments\": [
              \"${worker_repo_endpoint}\", 0, true
            ]
          }"
    
      # Jolokia returns HTTP 200 even if the response is a failure...
      # Parse the response to check the real status
      status=$(jq '.status' response.json)
      if [[ "${status}" -ne "200" ]]; then
        echo "Linking failed for worker"
        exit 1
      fi
    
      echo "Linked"
    }
    
    "$@"
---
# Source: gdb-ee/templates/persistence/graphdb-master-default-pv.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: graphdb-default-pv
  labels:
    name: graphdb-default-pv
spec:
  storageClassName: "standard"
  accessModes:
    - ReadWriteOnce
  capacity:
    storage: 10G
  hostPath:
    path: /data/graphdb-data
---
# Source: gdb-ee/templates/persistence/graphdb-worker-default-pv.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: graphdb-worker-default-worker-1-pv
  labels:
    name: graphdb-worker-default-worker-1-pv
spec:
  storageClassName: "standard"
  accessModes:
    - ReadWriteOnce
  capacity:
    storage: 10G
  hostPath:
    path: /data/graphdb-worker-1-data


#
# Default persistence volume for GraphDB workers. Data is stored on the node file system. Suitable
# for Minikube deployments.
#
# Note: Not to be used in production or multi node cluster.
#
---
# Source: gdb-ee/templates/persistence/graphdb-worker-default-pv.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: graphdb-worker-default-worker-2-pv
  labels:
    name: graphdb-worker-default-worker-2-pv
spec:
  storageClassName: "standard"
  accessModes:
    - ReadWriteOnce
  capacity:
    storage: 10G
  hostPath:
    path: /data/graphdb-worker-2-data
---
# Source: gdb-ee/templates/persistence/graphdb-master-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: graphdb-data-pvc
  labels:
    name: graphdb-data-pvc
spec:
  volumeName: graphdb-default-pv
  storageClassName: standard
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10G
---
# Source: gdb-ee/templates/persistence/graphdb-worker-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: graphdb-worker-1-data-pvc
  labels:
    name: graphdb-worker-1-data-pvc
spec:
  volumeName: graphdb-worker-default-worker-1-pv
  storageClassName: standard
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10G
---
# Source: gdb-ee/templates/persistence/graphdb-worker-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: graphdb-worker-2-data-pvc
  labels:
    name: graphdb-worker-2-data-pvc
spec:
  volumeName: graphdb-worker-default-worker-2-pv
  storageClassName: standard
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10G
---
# Source: gdb-ee/templates/gateway/kong.yaml
apiVersion: v1
kind: Service
metadata:
  name: kong-proxy
spec:
  selector:
    app: kong
  ports:
    - name: kong-proxy
      port: 8000
      targetPort: 8000
      protocol: TCP
---
# Source: gdb-ee/templates/gateway/kong.yaml
apiVersion: v1
kind: Service
metadata:
  name: kong-proxy-ssl
spec:
  selector:
    app: kong
  ports:
    - name: kong-proxy-ssl
      port: 8443
      targetPort: 8443
      protocol: TCP
---
# Source: gdb-ee/templates/gateway/kong.yaml
apiVersion: v1
kind: Service
metadata:
  name: kong-admin
spec:
  selector:
    app: kong
  ports:
    - name: kong-admin
      port: 8001
      targetPort: 8001
      protocol: TCP
---
# Source: gdb-ee/templates/gateway/kong.yaml
apiVersion: v1
kind: Service
metadata:
  name: kong-admin-ssl
spec:
  selector:
    app: kong
  ports:
    - name: kong-admin-ssl
      port: 8444
      targetPort: 8444
      protocol: TCP
---
# Source: gdb-ee/templates/gateway/kong.yaml
apiVersion: v1
kind: Service
metadata:
  name: kong-admin-outside
spec:
  selector:
    app: kong
  type: NodePort
  ports:
    - name: kong-admin-outside
      nodePort: 31122
      port: 8001
      protocol: TCP
      targetPort: 8001
  sessionAffinity: None
status:
  loadBalancer: {}
---
# Source: gdb-ee/templates/graphdb-master.yaml
apiVersion: v1
kind: Service
metadata:
  name: graphdb
  labels:
    app: graphdb
spec:
  selector:
    app: graphdb
  ports:
    - name: graphdb
      port: 7200
      targetPort: 7200
      protocol: TCP
---
# Source: gdb-ee/templates/graphdb-worker.yaml
apiVersion: v1
kind: Service
metadata:
  name: graphdb-worker-1
  labels:
    app: graphdb-worker-1
spec:
  selector:
    app: graphdb-worker-1
  ports:
    - name: graphdb-worker-1
      port: 7200
      targetPort: 7200
      protocol: TCP
---
# Source: gdb-ee/templates/graphdb-worker.yaml
apiVersion: v1
kind: Service
metadata:
  name: graphdb-worker-2
  labels:
    app: graphdb-worker-2
spec:
  selector:
    app: graphdb-worker-2
  ports:
    - name: graphdb-worker-2
      port: 7200
      targetPort: 7200
      protocol: TCP
---
# Source: gdb-ee/templates/gateway/kong.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kong
  labels:
    app: kong
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kong
  template:
    metadata:
      name: kong
      labels:
        app: kong
      annotations:
        # Enables redeployment if the configuration map or the declarative configuration is updated
        checksum/configmap: 327ac5b93a30f3a005b17c6642d22d4df61d725f8a5f3904ab7910e308db337b
        checksum/services-configmap: bb9ab343eedb2c544022b5d503a0bc7b1f480c26b3f3ab8e2b3d7f92b8959b87
    spec:
      volumes:
        - name: kong-services-config
          configMap:
            name: kong-services-configmap
      
      nodeSelector: 
        {}
      
      containers:
        - name: kong
          image: kong:2.1-alpine
          imagePullPolicy: IfNotPresent
          envFrom:
            - configMapRef:
                name: kong-configmap
          ports:
            - name: proxy
              containerPort: 8000
              protocol: TCP
            - name: proxy-ssl
              containerPort: 8443
              protocol: TCP
            - name: admin
              containerPort: 8001
              protocol: TCP
            - name: admin-ssl
              containerPort: 8444
              protocol: TCP
          volumeMounts:
            - name: kong-services-config
              mountPath: /etc/kong
          resources: 
            limits:
              memory: 2048Mi
          readinessProbe:
            exec:
              command: ["kong", "health"]
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            exec:
              command: ["kong", "health"]
            initialDelaySeconds: 5
            periodSeconds: 10
---
# Source: gdb-ee/templates/graphdb-master.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: graphdb
  labels:
    app: graphdb
spec:
  replicas: 1
  # Important to define this strategy instead of the default rolling update, otherwise when
  # performing helm update, GraphDB won't release its lock from the repositories and the new
  # pod won't be able to start.
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: graphdb
  template:
    metadata:
      labels:
        app: graphdb
    spec:
      terminationGracePeriodSeconds: 60
      volumes:
        - name: graphdb-license
          secret:
            #TODO: Add masters index
            secretName: graphdb-masters-license
        - name: graphdb-storage
          persistentVolumeClaim:
            claimName: graphdb-data-pvc
        - name: graphdb-repo-config
          configMap:
            name: graphdb-repo-default-configmap
      
      
      nodeSelector: 
        {}
      
      containers:
        - name: graphdb
          image: ontotext/graphdb:9.5.0-ee
          imagePullPolicy: IfNotPresent
          ports:
            - name: graphdb
              containerPort: 7200
          envFrom:
            - configMapRef:
                name: graphdb-configmap
          volumeMounts:
            - name: graphdb-storage
              mountPath: /opt/graphdb/home
          resources: 
            limits:
              memory: 4Gi
            requests:
              memory: 2Gi
          # Allow for GraphDB to start within 10*30 seconds before readiness & liveness probes interfere
          startupProbe:
            httpGet:
              path: /repositories
              port: graphdb
            failureThreshold: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /repositories
              port: graphdb
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /repositories
              port: graphdb
            initialDelaySeconds: 60
            periodSeconds: 10
      initContainers:
        # LICENSE PROVISION
        - name: provision-license
          image: busybox:1.31
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - name: graphdb-storage
              mountPath: /opt/graphdb/home
            - name: graphdb-license
              mountPath: /tmp/license/
          command: ['sh', '-c']
          args:
            - |
                mkdir -p /opt/graphdb/home/conf/
                cd /opt/graphdb/home/conf/
                [ -f graphdb.license ] && echo "License present, exiting..." && exit 0

                echo 'Provisioning GraphDB license'
                cp /tmp/license/graphdb.license ./graphdb.license
                echo 'Done'
        # REPO PROVISION
        - name: provision-repository
          image: busybox:1.31
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - name: graphdb-storage
              mountPath: /opt/graphdb/home
            - name: graphdb-repo-config
              mountPath: /tmp/graphdb
          command: ['sh', '-c']
          args:
            - |
              set -eu
              mkdir -p /opt/graphdb/home/data/repositories/soaas ;
              cd /opt/graphdb/home/data/repositories/soaas ;

              # If the repo configuration exists -> skip provisioning
              [ -f config.ttl ] && echo "Repository exists, exiting..." && exit 0

              echo 'Provisioning GraphDB soaas repository config.ttl' ;
              cp /tmp/graphdb/config.ttl ./config.ttl ;
              echo 'Done'
---
# Source: gdb-ee/templates/graphdb-worker.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: graphdb-worker-1
  labels:
    app: graphdb-worker-1
spec:
  replicas: 1
  # Important to define this strategy instead of the default rolling update, otherwise when
  # performing helm update, GraphDB won't release its lock from the repositories and the new
  # pod won't be able to start.
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: graphdb-worker-1
  template:
    metadata:
      labels:
        app: graphdb-worker-1
    spec:
      terminationGracePeriodSeconds: 60
      volumes:
        - name: graphdb-license
          secret:
            secretName: graphdb-worker1-license
        - name: graphdb-worker-storage
          persistentVolumeClaim:
            claimName: graphdb-worker-1-data-pvc
        - name: graphdb-worker-repo-config
          configMap:
            name: graphdb-worker-repo-default-configmap
        - name: graphdb-utils
          configMap:
            name: graphdb-utils-configmap
      
      
      nodeSelector: 
        {}
      
      containers:
        - name: graphdb-worker-1
          image: ontotext/graphdb:9.5.0-ee
          imagePullPolicy: IfNotPresent
          ports:
            - name: graphdb-w-1
              containerPort: 7200
          envFrom:
            - configMapRef:
                name: graphdb-worker-1-configmap
          volumeMounts:
            - name: graphdb-worker-storage
              mountPath: /opt/graphdb/home
            - name: graphdb-utils
              mountPath: /tmp/utils
          lifecycle:
            postStart:
              exec:
                # Always link the worker after starting the container.
                # This ensures proper state in most of the cases
                #TODO: For different topologies execute different script, for example linking the worker to more than 1 master if the topology is 2M3W_RW_RO or 2M3W_MUTED. Note that for 2M3W_MUTED you'll need some indicator to which master the current worker should be linked.
                command: [
                'sh',
                '-c',
                'apk add jq; cp /tmp/utils/graphdb.sh /usr/local/bin/graphdb.sh; chmod +x /usr/local/bin/graphdb.sh ; /usr/local/bin/graphdb.sh linkWorker "http://graphdb:7200" "http://graphdb-worker-1:7200" "soaas" "soaas"',
                '&>  /proc/1/fd/1'
                ]
          resources: 
            limits:
              memory: 4Gi
            requests:
              memory: 2Gi
          # Allow for GraphDB to start within 10*30 seconds before readiness & liveness probes interfere
          startupProbe:
            httpGet:
              path: /repositories
              port: graphdb-w-1
            failureThreshold: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /repositories
              port: graphdb-w-1
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /repositories
              port: graphdb-w-1
            initialDelaySeconds: 10
            periodSeconds: 10
      initContainers:
        # LICENSE PROVISION
        - name: provision-license
          image: busybox:1.31
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - name: graphdb-worker-storage
              mountPath: /opt/graphdb/home
            - name: graphdb-license
              mountPath: /tmp/license/
          command: ['sh', '-c']
          args:
            - |
                mkdir -p /opt/graphdb/home/conf/
                cd /opt/graphdb/home/conf/
                [ -f graphdb.license ] && echo "License present, exiting..." && exit 0

                echo 'Provisioning GraphDB worker 1 license'
                cp /tmp/license/graphdb.license ./graphdb.license
                echo 'Done'
        # REPO PROVISION
        - name: provision-worker-repository
          image: busybox:1.31
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - name: graphdb-worker-storage
              mountPath: /opt/graphdb/home
            - name: graphdb-worker-repo-config
              mountPath: /tmp/graphdb
          command: ['sh', '-c']
          args:
            - |
              set -eu
              mkdir -p /opt/graphdb/home/data/repositories/soaas ;
              cd /opt/graphdb/home/data/repositories/soaas ;

              # If the repo configuration exists -> skip provisioning
              [ -f config.ttl ] && echo "Repository exists, exiting..." && exit 0

              echo 'Provisioning GraphDB soaas repository config.ttl' ;
              cp /tmp/graphdb/config.ttl ./config.ttl ;
              echo 'Done'
        # We wait for master before starting the worker node. Easier for troubleshooting.
          #TODO: If more than 1 master, wait for all of them!
        - name: wait-master-node
          image: adoptopenjdk/openjdk11:alpine
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - name: graphdb-utils
              mountPath: /tmp/utils
          command: ['sh', '-c']
          args:
            - |
              set -eu
              apk add curl
              cp /tmp/utils/graphdb.sh /usr/local/bin/graphdb.sh;
              chmod +x /usr/local/bin/graphdb.sh
              graphdb.sh waitMaster "http://graphdb:7200" "soaas"
              echo "Done"
              exit 0
---
# Source: gdb-ee/templates/graphdb-worker.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: graphdb-worker-2
  labels:
    app: graphdb-worker-2
spec:
  replicas: 1
  # Important to define this strategy instead of the default rolling update, otherwise when
  # performing helm update, GraphDB won't release its lock from the repositories and the new
  # pod won't be able to start.
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: graphdb-worker-2
  template:
    metadata:
      labels:
        app: graphdb-worker-2
    spec:
      terminationGracePeriodSeconds: 60
      volumes:
        - name: graphdb-license
          secret:
            secretName: graphdb-workers-license
        - name: graphdb-worker-storage
          persistentVolumeClaim:
            claimName: graphdb-worker-2-data-pvc
        - name: graphdb-worker-repo-config
          configMap:
            name: graphdb-worker-repo-default-configmap
        - name: graphdb-utils
          configMap:
            name: graphdb-utils-configmap
      
      
      nodeSelector: 
        {}
      
      containers:
        - name: graphdb-worker-2
          image: ontotext/graphdb:9.5.0-ee
          imagePullPolicy: IfNotPresent
          ports:
            - name: graphdb-w-2
              containerPort: 7200
          envFrom:
            - configMapRef:
                name: graphdb-worker-2-configmap
          volumeMounts:
            - name: graphdb-worker-storage
              mountPath: /opt/graphdb/home
            - name: graphdb-utils
              mountPath: /tmp/utils
          lifecycle:
            postStart:
              exec:
                # Always link the worker after starting the container.
                # This ensures proper state in most of the cases
                #TODO: For different topologies execute different script, for example linking the worker to more than 1 master if the topology is 2M3W_RW_RO or 2M3W_MUTED. Note that for 2M3W_MUTED you'll need some indicator to which master the current worker should be linked.
                command: [
                'sh',
                '-c',
                'apk add jq; cp /tmp/utils/graphdb.sh /usr/local/bin/graphdb.sh; chmod +x /usr/local/bin/graphdb.sh ; /usr/local/bin/graphdb.sh linkWorker "http://graphdb:7200" "http://graphdb-worker-2:7200" "soaas" "soaas"',
                '&>  /proc/1/fd/1'
                ]
          resources: 
            limits:
              memory: 4Gi
            requests:
              memory: 2Gi
          # Allow for GraphDB to start within 10*30 seconds before readiness & liveness probes interfere
          startupProbe:
            httpGet:
              path: /repositories
              port: graphdb-w-2
            failureThreshold: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /repositories
              port: graphdb-w-2
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /repositories
              port: graphdb-w-2
            initialDelaySeconds: 10
            periodSeconds: 10
      initContainers:
        # LICENSE PROVISION
        - name: provision-license
          image: busybox:1.31
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - name: graphdb-worker-storage
              mountPath: /opt/graphdb/home
            - name: graphdb-license
              mountPath: /tmp/license/
          command: ['sh', '-c']
          args:
            - |
                mkdir -p /opt/graphdb/home/conf/
                cd /opt/graphdb/home/conf/
                [ -f graphdb.license ] && echo "License present, exiting..." && exit 0

                echo 'Provisioning GraphDB worker 2 license'
                cp /tmp/license/graphdb.license ./graphdb.license
                echo 'Done'
        # REPO PROVISION
        - name: provision-worker-repository
          image: busybox:1.31
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - name: graphdb-worker-storage
              mountPath: /opt/graphdb/home
            - name: graphdb-worker-repo-config
              mountPath: /tmp/graphdb
          command: ['sh', '-c']
          args:
            - |
              set -eu
              mkdir -p /opt/graphdb/home/data/repositories/soaas ;
              cd /opt/graphdb/home/data/repositories/soaas ;

              # If the repo configuration exists -> skip provisioning
              [ -f config.ttl ] && echo "Repository exists, exiting..." && exit 0

              echo 'Provisioning GraphDB soaas repository config.ttl' ;
              cp /tmp/graphdb/config.ttl ./config.ttl ;
              echo 'Done'
        # We wait for master before starting the worker node. Easier for troubleshooting.
          #TODO: If more than 1 master, wait for all of them!
        - name: wait-master-node
          image: adoptopenjdk/openjdk11:alpine
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - name: graphdb-utils
              mountPath: /tmp/utils
          command: ['sh', '-c']
          args:
            - |
              set -eu
              apk add curl
              cp /tmp/utils/graphdb.sh /usr/local/bin/graphdb.sh;
              chmod +x /usr/local/bin/graphdb.sh
              graphdb.sh waitMaster "http://graphdb:7200" "soaas"
              echo "Done"
              exit 0
---
# Source: gdb-ee/templates/gateway/ingress.yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ingress
  annotations:
    kubernetes.io/ingress.class: "nginx"
    
    nginx.ingress.kubernetes.io/proxy-body-size: 512M
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "5"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"

spec:
  
  rules:
    - host: "graphdb.local"
      http:
        paths:
          - path: /
            backend:
              serviceName: kong-proxy
              servicePort: 8000
---
# Source: gdb-ee/templates/graphdb-worker.yaml
# Loop over the replica count
---
# Source: gdb-ee/templates/persistence/graphdb-master-default-pv.yaml
#
# Default persistence volume for GraphDB. Data is stored on the node file system. Suitable for
# Minikube deployments.
#
# Note: Not to be used in production or multi node cluster.
#
---
# Source: gdb-ee/templates/persistence/graphdb-worker-default-pv.yaml
#
# Default persistence volume for GraphDB workers. Data is stored on the node file system. Suitable
# for Minikube deployments.
#
# Note: Not to be used in production or multi node cluster.
#

NOTES:
--------------------------------------------------------------------------------------------
   ____                 _     ____  ____      _____ _____
  / ___|_ __ __ _ _ __ | |__ |  _ \| __ )    | ____| ____|
 | |  _| '__/ _` | '_ \| '_ \| | | |  _ \    |  _| |  _|
 | |_| | | | (_| | |_) | | | | |_| | |_) |   | |___| |___
  \____|_|  \__,_| .__/|_| |_|____/|____/    |_____|_____|
                 |_|
--------------------------------------------------------------------------------------------
version: 9.5.0
GDB cluster: true

** Please be patient while the chart is being deployed and services are available **
You can check their status with kubectl get pods

Endpoints:
* GraphDB workbench: http://graphdb.local/graphdb
